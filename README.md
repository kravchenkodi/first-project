# Шпаргалка по Git
## Навигация
* `pwd` (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;
* `ls` (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;
* `ls -a` — покажи также скрытые файлы и папки, названия которых начинаются с символа .;
* `cd first-project` (от англ. change directory, «сменить директорию») — перейди в папку first-project;
* `cd first-project/html` — перейди в папку html, которая находится в папке first-project;
* `cd ..` — перейди на уровень выше, в родительскую папку;
* `cd ~` — перейди в домашнюю директорию (/Users/Username);
* `cd /` — перейди в корневую директорию.
## Работа с файлами и папками
### Создание
* `touch index.html` (англ. touch, «коснуться») — создай файл index.html в текущей папке;
* `touch index.html style.css script.js` — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;
* `mkdir second-project` (от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке.
### Копирование и перемещение
* `cp file.txt ~/my-dir` (от англ. copy, «копировать») — скопируй файл в другое место;
* `mv file.txt ~/my-dir` (от англ. move, «переместить») — перемести файл или папку в другое место.
### Чтение
* `cat file.txt` (от англ. concatenate and print, «объединить и распечатать») — распечатай содержимое текстового файла file.txt.
### Удаление
* `rm about.html` (от англ. remove, «удалить») — удали файл about.html;
* `rmdir images` (от англ. remove directory, «удалить директорию») — удали папку images;
* `rm -r` second-project (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит.
### Полезные возможности
* Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (`&&`).
* У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
* Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.
Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

## Шпаркалка Markdown
[Шпаргалка Markdown](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)  
[еще](https://www.markdownguide.org/cheat-sheet/)  
[и еще](https://doka.guide/tools/markdown/)

## Инициализируем репозиторий
### Сделать папку репозиторием — `git init`
Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду `git init` (от англ. initialize — «инициализировать»).  
Например, создайте папку first-project и сделайте её Git-репозиторием: перейдите в неё с помощью команды cd и выполните `git init`.  
```bash
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий
```
Вы можете создать папку в любом месте на компьютере. Но в этом случае не забывайте менять в наших примерах путь `~/dev/first-project` на тот, который ведёт к вашей папке. Помните, что не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.
В некоторых случаях при инициализации репозитория Git может показать объёмное сообщение, которое начинается со слов `Using 'master' as the name…`. Не пугайтесь: это не ошибка.
Также `git init` выведет сообщение вида `Initialized empty Git repository in <*ваша папка с проектом*>/.git/` (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»). В подпапке `.git` Git будет хранить всю служебную информацию.

### «Разгитить» папку, если что-то пошло не так, — rm -rf .git
Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку `.git`.
```bash
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git 
```
Разберём подробнее, что такое `-rf`:
ключ `-r` (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
ключ `-f` (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».
Будьте осторожны: в подпапке `.git` хранится история изменений. Если удалить `.git`, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.
### Проверить состояние репозитория — git status
После инициализации репозитория `first-project` запустите команду `git status` (от англ. status — «статус», «состояние») — она показывает текущее состояние репозитория.
Команда `git status` выведет:
- название текущей ветки: `On branch master` или `On branch main`;
- сообщение о том, что в репозитории ещё нет коммитов: `No commits yet`;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — `nothing to commit (create/copy files and use "git add" to track)`.

### Подготовить файлы к сохранению — `git add`
Создайте файлы `todo.txt` и `readme.txt` в папке `first-project` и запустите `git status`, чтобы посмотреть, что изменилось.
```bash
$ touch todo.txt
$ touch readme.txt
# создали файлы todo.txt и readme.txt

$ git status # проверили статус
```
Git сообщит, что в папке `first-project` есть `untracked files` (от англ. track — «следить», untracked — «неотслеженный», «неотслеживаемый») — ещё не отслеживаемые файлы `readme.txt` и `todo.txt`.

Состояние `untracked` значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.
Сейчас в `first-project` два файла. Мы хотим отслеживать состояние обоих, поэтому можем использовать команду `git add --all` (от англ. add — «добавить» + от англ. all — «всё»). Ключ, или флаг, `--all` позволяет подготовить к сохранению все файлы в репозитории.
```bash
$ git add --all # подготовили к сохранению все файлы в репозитории
$ git status # проверили статус 
```
Добавлять файлы можно и по одному, без ключа `--all`.
```bash
$ git add todo.txt
$ git add readme.txt
$ git status
```
Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.).
```bash
$ git add . # добавить всю текущую папку
$ git status
```
Получилось! Файлы, которые отмечены зелёным, теперь отслеживаются и готовы к сохранению. Но сохранения пока не произошло, потому что команда git add только запоминает текущее содержимое (контент) файла.
Если сейчас отредактировать любой из «зелёных» файлов в папке `first-project`, он перейдёт в состояние `modified` (англ. «изменённый») и будет и в «зелёном», и в «красном» списках.
Чтобы запомнить новое состояние файла, нужно снова ввести команду `git add` и передать в качестве параметра имя изменённого файла или ключ `--all`.
```bash
$ git add todo.txt
# или
$ git add --all 
```
Теперь файл `todo.txt` снова готов к сохранению! Будет сохранена последняя добавленная версия.
### Выполнить коммит — `git commit`
Сделать коммит можно командой `git commit` c ключом `-m` (от англ. message — «сообщение»), который присваивает коммиту сообщение.
Обычно в таком сообщении поясняется, в чём именно состояли изменения. Это как заметки на полях: благодаря им проще читать и понимать текст. Сообщение коммита выполняет те же функции — улучшает понимание и упрощает навигацию. Оно пишется после ключа `-m` в кавычках.
Например, перейдите в папку `first-project` и выполните коммит со следующим комментарием.
```bash
$ git commit -m ‘Мой первый коммит!’
```
После нажатия `Enter` текущая версия файлов будет сохранена в репозитории с сообщением Мой первый коммит!. Коммит (по названию команды `git commit`) — это по сути список файлов с их контентом.


Команда `git commit` выведет информацию о коммите.
1. `[master (root-commit) baa3b6e]` значит:
	* коммит был в ветке `master`;
	* `root-commit` — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
	* `baa3b6e` — сокращённый идентификатор коммита (подробнее об этом мы ещё расскажем).
2. 2 files changed, 1 insertion(+) значит:
	* изменились два файла (readme.txt и todo.txt);
	* одна строка была добавлена.  


Строки вида `create mode 100644 readme.txt` — это более подробная информация о новых (добавленных в Git) файлах.  
`create` (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово delete (англ. «удалить»).
`mode 100644` сообщает, что это обычный файл. Также возможны варианты `100755` для исполняемых файлов (например, что-нибудь.exe) и `120000` для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.
💡 Обратите внимание: после того как вы сделали первый коммит, команда `git status` перестала выводить сообщение `No commits yet` (англ. «ещё нет коммитов»).

## SSH kyes
### Генерируем SSH-ключ
Обычно SSH-ключи находятся в директории `.ssh/`. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды.

```bash
$ ls -la .ssh/ # вывели список созданных ключей 
```

1. Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду.  
```bash
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.  
Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519.   
Ничего страшного: используйте другой алгоритм.  
```bash$ 
ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
``` 
После ввода отобразится такое сообщение.    
```bash
> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи
```
2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.
3. Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter для подтверждения.  
```bash
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again]
```
4. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду.
```bash
ls -a ~/.ssh
```
На экране должны появиться два файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому! 

После выполнения команды `ssh-keygen` из предыдущего урока в директории ~/.ssh будет создано два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали):
id_ed25519/id_rsa — приватный ключ (файл без .pub в конце). Ни в коем случае не копируйте его и не делитесь им.
id_ed25519.pub/id_rsa.pub — публичный ключ (на это указывает расширение .pub).
1. Скопируйте содержимое файла с публичным ключом в буфер обмена.
```bash
# Windows
# скопировать содержимое ключа в буфер обмена:
$ clip < ~/.ssh/id_rsa.pub
# для ed25519:
$ clip < ~/.ssh/id_ed25519.pub
```
Если clip не сработает, выведите содержимое файла с помощью `cat ~/.ssh/id_rsa.pub` или `cat ~/.ssh/id_ed25519.pub` и скопируйте вывод в буфер обмена из консоли.
2. Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта. <br>
В меню слева нажмите на пункт SSH and GPG keys. <br>
В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»). <br>
В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»). <br>
В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»). <br> 
В поле Key скопируйте ваш ключ из буфера обмена. <br>
Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»). <br>
Проверьте правильность ключа с помощью следующей команды.
```bash
$ ssh -T git@github.com 
```
```bash
Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
```
Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub по этой [ссылке](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.

## Привязать удалённый репозиторий к локальному — `git remote add`
Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно. Откройте консоль, перейдите в каталог локального репозитория и введите команду `git remote add` (от англ. remote — «удалённый» и add — «добавить»).
```bash
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
```
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово `origin`. А URL вы скопировали со страницы удалённого репозитория.  
**remark:**  
*В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания Ctrl+V. На Windows (в Git Bash) и Linux для этого используется сочетание `Ctrl+Shift+V`. Также можно нажать правую кнопку мыши и выбрать пункт Paste (англ. «вставить») в выпадающем меню.*


`origin` (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.  
Убедиться, что репозитории связаны, — `git remote -v`.  
Отлично: вы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.
```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```
В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.
## Синхронизируем локальный и удалённый репозитории
Самая первая ветка в репозитории появляется автоматически и называется main (англ. «основная») или master. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.

### Отправить изменения на удалённый репозиторий — git push
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью `git add`, закоммитили их с комментарием командой `git commit -m`. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда `git push` (от англ. push — «толкать»).
В первый раз эту команду нужно вызвать с флагом `-u` и параметрами `origin` (имя удалённого репозитория) и *main* или *master* (название текущей ветки). Флаг `-u` свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.
```bash
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master.
```
При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.
Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.




--------------------------------

# развлечения с маркдаун
текст 1 <br>
*текст 2*  
**текст 3**  
~~текст 4 delete~~
`текст 5`

## Список
1. один
2. два
3. три

е щ е:  
* один
* два 
* три

## Код

```python
s = "Подсветка Python"
print(s)
```

```
Язык не указан, синтаксис не подсвечен.
Но мы вставим в него <b>тег</b>.
```

| Таблицы       | Это                | Круто |
| ------------- |:------------------:| -----:|
| столбец 3     | выровнен вправо    | $1600 |
| столбец 2     | выровнен по центру |   $12 |
| зебра-строки  | прикольные         |    $1 |

## Строки

Это начальная строка

Эта строка отделена от предыдущей двумя новыми строками и станет *отдельным абзацем*.

Это тоже отдельный абзац, но...  
Эта строка отделена одной новой строкой, поэтому она находится в *том же абзаце*.

## Ссылки

[Обычная ссылка в строке](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)

[Обычная ссылка с title](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5 "Шпаркалка Markdown")

[Ссылка со сноской][Произвольный регистронезависимый текст]

[Относительная ссылка на документ](../blob/master/LICENSE)

[Для ссылок со сноской можно использовать цифры][1]

Или можно просто вставить ссылку в квадратные скобки [https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5]

Произвольный текст, после которого можно привести ссылки.

[произвольный регистронезависимый текст]: https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5
[1]: https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5
[текст ссылки]: https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5