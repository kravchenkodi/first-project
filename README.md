# Шпаргалка по Git
## Навигация
* `pwd` (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;
* `ls` (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;
* `ls -a` — покажи также скрытые файлы и папки, названия которых начинаются с символа .;
* `cd first-project` (от англ. change directory, «сменить директорию») — перейди в папку first-project;
* `cd first-project/html` — перейди в папку html, которая находится в папке first-project;
* `cd ..` — перейди на уровень выше, в родительскую папку;
* `cd ~` — перейди в домашнюю директорию (/Users/Username);
* `cd /` — перейди в корневую директорию.
## Работа с файлами и папками
### Создание
* `touch index.html` (англ. touch, «коснуться») — создай файл index.html в текущей папке;
* `touch index.html style.css script.js` — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;
* `mkdir second-project` (от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке.
### Копирование и перемещение
* `cp file.txt ~/my-dir` (от англ. copy, «копировать») — скопируй файл в другое место;
* `mv file.txt ~/my-dir` (от англ. move, «переместить») — перемести файл или папку в другое место.
### Чтение
* `cat file.txt` (от англ. concatenate and print, «объединить и распечатать») — распечатай содержимое текстового файла file.txt.
### Удаление
* `rm about.html` (от англ. remove, «удалить») — удали файл about.html;
* `rmdir images` (от англ. remove directory, «удалить директорию») — удали папку images;
* `rm -r` second-project (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит.
### Полезные возможности
* Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (`&&`).
* У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
* Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.
Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

## Шпаркалка Markdown
[Шпаргалка Markdown](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)  
[еще](https://www.markdownguide.org/cheat-sheet/)  
[и еще](https://doka.guide/tools/markdown/)
### mermaid schemes
[mermaid schemes](https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/)  
[и еще](https://docs.github.com/ru/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams#creating-mermaid-diagrams)  
[onlain flowchart](https://mermaid.live/edit#pako:eNpVjstqw0AMRX9FaNVC_ANeFBq7zSbQQrPzZCFsOTMk80CWCcH2v3ccb1qtxD3nCk3Yxo6xxP4W760lUTjVJkCe96ay4gb1NJyhKN7mAyv4GPgxw_7lEGGwMSUXLq-bv18lqKbjqjGodeG6bKh69r8Cz1A3R0oa0_kvOd3jDB-N-7b5_H9ihXPrs-mp7KloSaAieSq4Q8_iyXX5_WlNDKplzwbLvHYkV4MmLNmjUePPI7RYqoy8wzF1pFw7ugj5LVx-AfLqVWg)

## Инициализируем репозиторий
### Сделать папку репозиторием — `git init`
Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду `git init` (от англ. initialize — «инициализировать»).  
Например, создайте папку first-project и сделайте её Git-репозиторием: перейдите в неё с помощью команды cd и выполните `git init`.  
```bash
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий
```
Вы можете создать папку в любом месте на компьютере. Но в этом случае не забывайте менять в наших примерах путь `~/dev/first-project` на тот, который ведёт к вашей папке. Помните, что не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.
В некоторых случаях при инициализации репозитория Git может показать объёмное сообщение, которое начинается со слов `Using 'master' as the name…`. Не пугайтесь: это не ошибка.
Также `git init` выведет сообщение вида `Initialized empty Git repository in <*ваша папка с проектом*>/.git/` (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»). В подпапке `.git` Git будет хранить всю служебную информацию.

### «Разгитить» папку, если что-то пошло не так, — rm -rf .git
Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку `.git`.
```bash
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git 
```
Разберём подробнее, что такое `-rf`:
ключ `-r` (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
ключ `-f` (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».
Будьте осторожны: в подпапке `.git` хранится история изменений. Если удалить `.git`, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.
### Проверить состояние репозитория — git status
После инициализации репозитория `first-project` запустите команду `git status` (от англ. status — «статус», «состояние») — она показывает текущее состояние репозитория.
Команда `git status` выведет:
- название текущей ветки: `On branch master` или `On branch main`;
- сообщение о том, что в репозитории ещё нет коммитов: `No commits yet`;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — `nothing to commit (create/copy files and use "git add" to track)`.

### Подготовить файлы к сохранению — `git add`
Создайте файлы `todo.txt` и `readme.txt` в папке `first-project` и запустите `git status`, чтобы посмотреть, что изменилось.
```bash
$ touch todo.txt
$ touch readme.txt
# создали файлы todo.txt и readme.txt

$ git status # проверили статус
```
Git сообщит, что в папке `first-project` есть `untracked files` (от англ. track — «следить», untracked — «неотслеженный», «неотслеживаемый») — ещё не отслеживаемые файлы `readme.txt` и `todo.txt`.

Состояние `untracked` значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.
Сейчас в `first-project` два файла. Мы хотим отслеживать состояние обоих, поэтому можем использовать команду `git add --all` (от англ. add — «добавить» + от англ. all — «всё»). Ключ, или флаг, `--all` позволяет подготовить к сохранению все файлы в репозитории.
```bash
$ git add --all # подготовили к сохранению все файлы в репозитории
$ git status # проверили статус 
```
Добавлять файлы можно и по одному, без ключа `--all`.
```bash
$ git add todo.txt
$ git add readme.txt
$ git status
```
Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.).
```bash
$ git add . # добавить всю текущую папку
$ git status
```
Получилось! Файлы, которые отмечены зелёным, теперь отслеживаются и готовы к сохранению. Но сохранения пока не произошло, потому что команда git add только запоминает текущее содержимое (контент) файла.
Если сейчас отредактировать любой из «зелёных» файлов в папке `first-project`, он перейдёт в состояние `modified` (англ. «изменённый») и будет и в «зелёном», и в «красном» списках.
Чтобы запомнить новое состояние файла, нужно снова ввести команду `git add` и передать в качестве параметра имя изменённого файла или ключ `--all`.
```bash
$ git add todo.txt
# или
$ git add --all 
```
Теперь файл `todo.txt` снова готов к сохранению! Будет сохранена последняя добавленная версия.
### Выполнить коммит — `git commit`
Сделать коммит можно командой `git commit` c ключом `-m` (от англ. message — «сообщение»), который присваивает коммиту сообщение.
Обычно в таком сообщении поясняется, в чём именно состояли изменения. Это как заметки на полях: благодаря им проще читать и понимать текст. Сообщение коммита выполняет те же функции — улучшает понимание и упрощает навигацию. Оно пишется после ключа `-m` в кавычках.
Например, перейдите в папку `first-project` и выполните коммит со следующим комментарием.
```bash
$ git commit -m ‘Мой первый коммит!’
```
После нажатия `Enter` текущая версия файлов будет сохранена в репозитории с сообщением Мой первый коммит!. Коммит (по названию команды `git commit`) — это по сути список файлов с их контентом.


Команда `git commit` выведет информацию о коммите.
1. `[master (root-commit) baa3b6e]` значит:
	* коммит был в ветке `master`;
	* `root-commit` — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
	* `baa3b6e` — сокращённый идентификатор коммита (подробнее об этом мы ещё расскажем).
2. 2 files changed, 1 insertion(+) значит:
	* изменились два файла (readme.txt и todo.txt);
	* одна строка была добавлена.  


Строки вида `create mode 100644 readme.txt` — это более подробная информация о новых (добавленных в Git) файлах.  `create` (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово `delete` (англ. «удалить»).
`mode 100644` сообщает, что это обычный файл. Также возможны варианты `100755` для исполняемых файлов (например, что-нибудь.exe) и `120000` для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.
💡 Обратите внимание: после того как вы сделали первый коммит, команда `git status` перестала выводить сообщение `No commits yet` (англ. «ещё нет коммитов»).
### Просмотреть историю коммитов — `git log`
Чтобы увидеть все коммиты, введите команду `git log` (от англ. log — «журнал [записей]»).
Обратите внимание, что по умолчанию `git log` выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

### Удаление Git Remote
Чтобы удалить пульт, перейдите в каталог, в котором хранится ваш репозиторий, и используйте команду `git remote rm` (или `git remote remove ...` ), за которой следует имя удаленного:
```bash
git remote rm <remote-name>
```
Например, чтобы удалить удаленное именованное `testing`, введите:
```bash
git remote rm testing
```
`git remote rm` удаляет все ссылки на удаленный репозиторий. Он не удаляет репозиторий с удаленного сервера.

Чтобы убедиться, что пульт был успешно удален, используйте команду `git remote -v` для списка удаленных подключений:
```bash
git remote -v
```
Результат будет выглядеть примерно так:
```bash
origin	https://github.com/user/repo_name.git (fetch)
origin	https://github.com/user/repo_name.git (push)
```
Команда `git remote rm` удаляет записи об удаленном репозитории из файла `.git/config`.
------------------

## SSH kyes
### Генерируем SSH-ключ
Обычно SSH-ключи находятся в директории `.ssh/`. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды.

```bash
$ ls -la .ssh/ # вывели список созданных ключей 
```

1. Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду.  
```bash
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.  
Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519.   
Ничего страшного: используйте другой алгоритм.  
```bash$ 
ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
``` 
После ввода отобразится такое сообщение.    
```bash
> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи
```
2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.
3. Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter для подтверждения.  
```bash
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again]
```
4. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду.
```bash
ls -a ~/.ssh
```
На экране должны появиться два файла — один с расширением `.pub`, другой — без. Файл в `.pub` — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому! 

После выполнения команды `ssh-keygen` из предыдущего урока в директории `~/.ssh` будет создано два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали):
`id_ed25519/id_rsa` — приватный ключ (файл без `.pub` в конце). Ни в коем случае не копируйте его и не делитесь им.
`id_ed25519.pub/id_rsa.pub` — публичный ключ (на это указывает расширение `.pub`).
1. Скопируйте содержимое файла с публичным ключом в буфер обмена.
```bash
# Windows
# скопировать содержимое ключа в буфер обмена:
$ clip < ~/.ssh/id_rsa.pub
# для ed25519:
$ clip < ~/.ssh/id_ed25519.pub
```
Если `clip` не сработает, выведите содержимое файла с помощью `cat ~/.ssh/id_rsa.pub` или `cat ~/.ssh/id_ed25519.pub` и скопируйте вывод в буфер обмена из консоли.
2. Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта. <br>
В меню слева нажмите на пункт SSH and GPG keys. <br>
В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»). <br>
В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»). <br>
В поле `Key type` (англ. «тип ключа») должно быть `Authentication Key` (англ. «ключ аутентификации»). <br> 
В поле Key скопируйте ваш ключ из буфера обмена. <br>
Нажмите на кнопку `Add SSH key` (англ. «добавить SSH-ключ»). <br>
Проверьте правильность ключа с помощью следующей команды.
```bash
$ ssh -T git@github.com 
```
```bash
Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
```
Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub по этой [ссылке](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.

## Привязать удалённый репозиторий к локальному — `git remote add`
Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно. Откройте консоль, перейдите в каталог локального репозитория и введите команду `git remote add` (от англ. remote — «удалённый» и add — «добавить»).
```bash
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
```
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово `origin`. А URL вы скопировали со страницы удалённого репозитория.  
**remark:**  
*В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания `Ctrl+V. На Windows (в Git Bash) и Linux для этого используется сочетание `Ctrl+Shift+V`. Также можно нажать правую кнопку мыши и выбрать пункт Paste (англ. «вставить») в выпадающем меню.*


`origin` (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.  
Убедиться, что репозитории связаны, — `git remote -v`.  
Отлично: вы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.
```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```
В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
Флаг `-v` — короткая форма флага `--verbose` (англ. «подробный»). Он позволяет показать больше информации в выводе.
## Синхронизируем локальный и удалённый репозитории
Самая первая ветка в репозитории появляется автоматически и называется `main` (англ. «основная») или `master`. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.

### Отправить изменения на удалённый репозиторий — `git push`
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью `git add`, закоммитили их с комментарием командой `git commit -m`. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда `git push` (от англ. push — «толкать»).
В первый раз эту команду нужно вызвать с флагом `-u` и параметрами `origin` (имя удалённого репозитория) и `main` или `master` (название текущей ветки). Флаг `-u` свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.
```bash
$ git push -u origin master # Если команда приведёт к ошибке, попробуйте 
                          # заменить master на main.
```
При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.
Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.

## Хеш — идентификатор коммита
### Что такое хеш. Хеширование коммитов
`Хеширование` (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их `«отпечаток»` (англ. fingerprint).
Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или **родительский** (англ. parent), коммит.
Git хеширует (преобразует) информацию о коммите с помощью алгоритма **SHA-1** (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный **хеш** — результат хеширования.
Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 
0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:
* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).
Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 на этом [сайте](https://emn178.github.io/online-tools/sha1.html) — попробуйте ввести в поле **input** (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле **output** (англ. «вывод»).
### Хеш — основной идентификатор коммита
Git хранит таблицу соответствий `хеш → информация о коммите`. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.
При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке `.git` в репозитории проекта.

## ЛОГ

После вызова `git log` появляется список коммитов.
Вот так выглядит описание самого первого коммита в репозитории Git
```bash
commit e83c5163316f89bfbde7d9ab23ca2e25604af290 # хэш коммита
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 7 15:13:13 2005 -0700

    Initial revision of "git", the information manager from hell 
```
### Получить сокращённый лог — `git log --oneline`
Получить сокращённый лог можно с помощью команды `git log` с флагом `--oneline` (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда `git log --oneline` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.
**remark**
Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу `Q` (от англ. Quit — «выйти») в английской раскладке клавиатуры.

### HEAD — всему голова
При вызове команды `git log` вы также могли заметить надпись `(HEAD -> master)` после хеша одного из коммитов.
#### Файл HEAD
Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git. Он указывает на коммит, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейдите в папку `.git` командой `cd`. Посмотрите содержимое файла `HEAD` командой `cat`.
```bash
$ pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка 
```
Внутри `HEAD` — ссылка на служебный файл: `refs/heads/master` (или refs/heads/main` в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
```bash
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты 
```
Когда вы делаете коммит, Git обновляет `refs/heads/master` — записывает в него хеш последнего коммита. Получается, что `HEAD` тоже обновляется, так как ссылается на `refs/heads/master`.
При работе с Git указатель `HEAD` используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово `HEAD` — Git поймёт, что вы имели в виду последний коммит.

## Статусы файлов в Git
До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог `git add`, а можно было просто сделать коммит (svn commit). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.
Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. Хотя сначала это может показаться сложным, со временем вы оцените удобство более явного подхода.

### Статусы `untracked/tracked`, `staged и `modified`
* `untracked` (англ. «неотслеживаемый»)
	Мы говорили, что новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
* `staged` (англ. «подготовленный»)
	После выполнения команды `git add` файл попадает в `staging area` (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.

Если сравнивать коммит с фотографией, то можно сказать, что команда `git add` добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а `git commit` делает снимок всей сцены целиком.   
**Staging area, index и cache**
Staging area также называют **index** (англ. «каталог») или **cache** (англ. «кеш»), а состояние файла `staged` иногда называют indexed` или `cached`.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow.
* tracked (англ. «отслеживаемый»)
	Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit`, а также файлы, которые были добавлены в staging area` командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* modified (англ. «изменённый»)
	Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.  
Для файлов в состояниях `staged` и `modified обычно не указывают, что они также `tracked, потому что это состояние подразумевается.
#### Про `staged` и `modified`
Команда `git add` добавляет в `staging area` только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените `file.txt`, то новое содержимое файла не будет находиться в `staging`.
Git сообщит об этом с помощью статуса modified`: файл изменён относительно той версии, которая уже в `staging`. Чтобы добавить в `staging` последнюю версию, нужно выполнить `git add file.txt` ещё раз.

### Типичный жизненный цикл файла в Git
1. Файл только что создали. Git про него ещё ничего не знает. Состояние: `untracked`.
2. Файл добавили в `staging area` с помощью `git add`. Состояние: `staged` (+ `tracked`).
	* Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`).
		Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий.
	* Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).
3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.
4. Изменили файл. Состояние: `modified` (+ `tracked`).
5. Снова добавили в staging area с помощью `git add`. Состояния: `staged` (+ `tracked`).
6. Сделали коммит. Состояния: `tracked`.
7. Повторили пункты 4−7 много-много раз.

### SCHEME

```mermaid
      flowchart TD;
      untracked-->|git add| staged; 
      staged-->|git commit| tracked;
      tracked-->|file's changies| modified;
      modified-->|git add| staged;
      staged-->|file's changies| modified;
```

## git status
Большинство файлов в типичном проекте будут находиться в состоянии `tracked` (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды `git status` — иначе она бы каждый раз выводила список вообще всех файлов проекта.
В итоге `git status` показывает только следующие состояния файлов:
* `staged` (`Changes to be committed в выводе git status`);
* `modified` (`Changes not staged for commit`);
* `untracked` (`Untracked files`).

## Правки в уже сделанный коммит

Иногда в только что выполненном коммите нужно что-то поменять: например, добавить ещё пару файлов или заменить сообщение на более информативное.
В таком случае можно внести правки в уже сделанный коммит с помощью опции `--amend` (от англ. amend — «исправить», «дополнить») у команды `commit: git commit --amend`.
**__ВАЖНО__**: опция `--amend` работает только с последним коммитом (`HEAD`). Для исправления более ранних коммитов есть другие команды. 

### Дополнить коммит новыми файлами — `git commit --amend --no-edit`
Представьте, что делаете небольшой сайт и для этого создали файл-страницу `main.html`, а также файл со стилями `common.css`.
```bash
$ touch main.html
$ touch common.css
# дальше отредактировали оба файла
```
В какой-то момент вы забыли о файле common.css и добавили в коммит только `main.html`.
```bash
$ git add main.html
$ git commit -m "Добавить главную страницу"
$ git log --oneline
777fec3 Добавить главную страницу
```
Напомним, что если вы повторяете за нами эти действия локально, у вас будут другие хеши коммитов.
Файл `common.css` так и остался «висеть» в untracked. В этом легко убедиться, если вызвать `git status`.
```bash
$ git status
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
          common.css

nothing added to commit but untracked files present (use "git add" to track)
```
Дополните последний коммит забытым файлом `common.css` с помощью опции `--amend`.
```bash
$ git add common.css
# добавили файл common.css в список на коммит как обычно

# но вместо команды commit -m '...'
# будет:
$ git commit --amend --no-edit

$ git log --oneline
8340eb2 Добавить главную страницу
# коммит в истории всё ещё один (но у него новый хеш)
```
С опцией `--amend` команда `commit` не создаст новый коммит, а дополнит последний, просто добавив в него файл `common.css`. При этом хеш последнего коммита изменится, потому что изменился список файлов в коммите.
Обратите внимание на опцию `--no-edit`. Она сообщает команде `commit`, что сообщение коммита нужно оставить как было.
Точно так же можно добавить не новый файл, а дополнительные изменения в уже добавленном в коммит файле.
```bash
# ещё раз отредактировали main.html

$ git add main.html # добавили в список на коммит
$ git commit --amend --no-edit
```
### Изменить сообщение коммита — `git commit --amend -m`
Может быть и так, что добавлять новые файлы в коммит не нужно, зато понадобилось изменить сообщение.
Допустим, хочется заменить сообщение Добавить главную страницу на Добавить главную страницу и стили. Сделать это можно через `commit --amend` с флагом `-m`.
```bash
$ git commit --amend -m "Добавить главную страницу и стили"
$ git log --oneline
a31fa24 Добавить главную страницу и стили
```
Хеш коммита снова поменялся, потому что изменились сообщение и время коммита. При этом файлы в коммите остались те же: `main.html` и `common.css`.
#### Случилось страшное: открылся редактор
Если забыть указать у команды `git commit --amend` один из флагов (`--no-edit` или `-m`), Git предложит отредактировать сообщение коммита вручную. Для этого он откроет текстовый редактор, который установлен в системе по умолчанию. Чаще всего это либо GNU nano, либо Vim (лучше сразу закрыть).  
[инфо по nano](https://practicum.yandex.ru/trainer/git-basics/lesson/298b9e02-74a7-43be-8056-5780c0e04985/)

## Как откатиться назад, если «всё сломалось»
На разных этапах работы с Git могут происходить похожие ситуации:
* В список на коммит попал лишний файл (например, временный). Нужно «вынуть» его из списка.
* Последние несколько коммитов ошибочные: например, сделали не то, что было нужно, или нарушили логику. Хочется «откатить» сразу несколько коммитов, вернуть «как было вчера».
* Случайно изменился файл, который вообще не должен был меняться. Например, вы открыли не тот файл в редакторе и начали его исправлять.

## Выполнить unstage изменений — `git restore --staged <file>`
Допустим, вы создали или изменили какой-то файл и добавили его в список «на коммит» (`staging area`) с помощью `git add`, но потом передумали включать его туда. Убрать файл из `staging` поможет команда `git restore --staged <file>` (от англ. restore — «восстановить»).
💡 В выводе команды `git status` есть подсказка в скобках: `use "git restore --staged <file>..." to unstage`. Так что, даже если вы и забыли эту команду, Git напомнит вам.
В терминале это будет выглядеть примерно так.
```bash
$ touch example.txt # создали ненужный файл
$ git add example.txt # добавили его в staged

$ git status # проверили статус
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   example.txt

$ git restore --staged example.txt
$ git status # проверили статус

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        example.txt

no changes added to commit (use "git add" and/or "git commit -a")
# файл example.txt из staged вернулся обратно в untracked
```
Вызов `git restore --staged example.txt` перевёл `example.txt` из `staged обратно в `untracked`.
Чтобы «сбросить» все файлы из `staged` обратно в `untracked/modified, можно воспользоваться командой `git restore --staged .`: она сбросит всю текущую папку (.).

### «Откатить» коммит — `git reset --hard <commit hash>`
Иногда нужно «откатить» то, что уже было закоммичено, то есть вернуть состояние репозитория к более раннему. Для этого используют команду `git reset --hard <commit hash>` (от англ. reset  — «сброс», «обнуление» и hard — «суровый»).
```bash
$ git log --oneline # хеш можно найти в истории
7b972f5 (HEAD -> master) style: добавить комментарии, расставить отступы
b576d89 feat: добавить массив Expenses и цикл для добавления трат # вот сюда и вернёмся
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()

$ git reset --hard b576d89
# теперь мы на этом коммите
HEAD is now at b576d89 feat: добавить массив Expenses и цикл для добавления трат 
```
Теперь коммит `b576d89` стал последним: вся дальнейшая разработка будет вестись от него. Файл также вернулся к тому состоянию, в котором был в момент этого коммита. А коммит `7b972f5` Git просто удалил. Это можно проверить, снова запросив лог. Он покажет следующее.
```bash
$ git log --oneline
b576d89 (HEAD -> master) feat: добавить массив Expenses и цикл для добавления трат
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses() 
```
Будьте осторожны с командой `git reset --hard!` При удалении коммитов можно потерять что-то нужное.

### «Откатить» изменения, которые не попали ни в `staging`, ни в коммит, — `git restore <file>`
Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в `Changes not staged for commit (modified)`. Чтобы вернуть всё «как было», можно выполнить команду `git restore <file>`.
```bash
# случайно изменили файл example.txt
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   example.txt

$ git restore example.txt
$ git status
On branch main
nothing to commit, working tree clean
```
Изменения в файле «откатятся» до последней версии, которая была сохранена через `git commit` или `git add.`

## Просматриваем изменения в файлах
При работе с Git часто нужно узнать, что конкретно изменится или уже изменилось после того или иного коммита. Вот примеры таких ситуаций:
* Вы собираетесь сделать коммит, но хотите проверить (или перепроверить), какие именно изменения в него попадут.
* Вчера ваш коллега сделал коммит с сообщением small fix (англ. «небольшое исправление»), после чего тесты проекта начали «падать». Чтобы разобраться в ситуации, нужно посмотреть, что изменилось в этом коммите.
Всё это позволяет делать команда `git diff` (от англ. difference — «отличие», «разница»).   
Если коротко:
* Команда `git diff` сравнит последнюю закоммиченную версию файла с той, что находится в состоянии `modified`.
* Команда `git diff --staged` покажет изменения в `staged-файлах` относительно последних закоммиченных версий.

## Подготавливаем репозиторий
Историю масштабных и неожиданных изменений как нельзя лучше иллюстрирует сказка «Теремок».  
1. Создайте вместе с нами следующий репозиторий.
```bash
$ mkdir ~/dev/teremok
$ cd ~/dev/teremok
$ git init
# пропустим вывод git init, тут он не важен 
```
Добавьте файл teremok.txt и запишите в нём состояние теремка.
```bash
$ touch teremok.txt
# отредактируйте файл teremok.txt, добавьте в него строки:
# Теремок стоит, и в нём:
# никого нет
$ cat teremok.txt
Теремок стоит, и в нём:
никого нет 
```
Теперь выполните коммит.
```bash
$ git add teremok.txt
$ git commit -m "Исходное состояние теремка" 
```  
2. Селим мышку-норушку
Откройте и отредактируйте файл teremok.txt, чтобы вместо никого нет стало Мышка-норушка. Сохраните файл, но не делайте коммит. Затем воспользуйтесь командой git status, чтобы посмотреть, что происходит с файлами.  
Видно, что в теремке произошли какие-то изменения, но не видно, какие именно. Запустите git diff, чтобы выяснить детали. Эта команда сравнит последнюю закоммиченную версию файла teremok.txt с текущей (изменённой) версией.    
Самое важное `git diff` выводит в конце:
* красный цвет строки никого нет значит, что эта строка была удалена;
* зелёный цвет строки Мышка-норушка значит, что она была добавлена.  
Не все консоли умеют выводить цвета, поэтому строки помечаются не только цветом, но и знаком `-` или `+`. Минус — это удалённые строки, плюс — это добавленные.  
Коротко разберём остальные строки вывода команды:
* Первые две строки `(diff --git a/... b/... и index 901da07..ac459e1 100644`) — это низкоуровневая техническая информация. Мы не будем на ней останавливаться.
* Строки `--- a/teremok.txt и +++ b/teremok.txt` говорят, что дальше будет выведен результат сравнения файлов `a/teremok.txt` и `b/teremok.txt` — исходной и текущей версий.
* Строка `@@ -1,2 +1,2 @@` сообщает, какие строки файла попали в сравнение. Выражение `1,2` (неважно, с плюсом или с минусом) говорит, что были использованы две строки, начиная с первой. Если бы было, например, написано `+15,7`, это значило бы, что в сравнении участвуют 7 строк, начиная с 15-й.

Выражение со знаком минус (`-1,2`) относится к «оригинальной» версии файла (`a/teremok.txt`), а со знаком плюс (`+1,2`) — к «изменённой» (`b/teremok.txt`).

### Просматриваем изменения в staging area
Подготовьте мышку-норушку к коммиту, но пока не выполняйте его.
```bash
$ git add teremok.txt
```
Вам наверняка знакома ситуация: вы выключили плиту и утюг, но вернулись проверить, всё ли точно в порядке. Сделайте что-то похожее с вашими изменениями: перепроверьте, что всё на месте.
```bash
$ git diff
# команда не выведет ничего! 
```
Не волнуйтесь: изменения не потерялись. Просто по умолчанию команда `git diff` не показывает изменения в `staged-файлах` — только в `modified`.
Чтобы всё-таки просмотреть изменения в `staged`, нужно использовать флаг `--staged`: `git diff --staged`.

## Сопоставляем коммиты

### Дописываем строку в файл
Чтобы продолжить сказку, вам нужно будет дописывать новые строки в конец файла `teremok.txt`. Для этого подходит команда `echo` (англ. «эхо»). Разберём её.
Сама по себе эта команда просто выводит в консоль то, что ей передали в качестве параметра.
```bash
$ echo "Привет!"
Привет! 
```
Но если скомбинировать `echo` с символами перенаправления вывода `>>` (два знака «больше»), то всё, что должно было попасть на экран, вместо этого будет записано в файл.
```bash
$ cat file.txt
Первая строка файла

$ echo "Вторая строка файла" >> file.txt
$ cat file.txt
Первая строка файла
Вторая строка файла 
```
Оператор `>>` — это возможность командной строки (Bash). Его можно использовать не только с `echo`, но и с любой другой командой, которая выводит что-то на экран.
Одинарный символ `>` тоже перенаправит вывод команды в файл, но перед этим сотрёт содержимое файла, то есть перезапишет файл целиком.
```bash
$ cat file.txt
Первая строка файла
$ echo "Новая строка" > file.txt
$ cat file.txt
Новая строка 
```
Обратите внимание, что после использования символа > Первая строка файла исчезла.

### Селим всех остальных
Вернёмся к сказке. Сделайте по коммиту для каждого нового персонажа. Используйте команду `echo` или дописывайте строки вручную в любом текстовом редакторе.
```bash
$ echo "Лягушка-квакушка" >> teremok.txt
$ git add teremok.txt
$ git commit -m "Поселить лягушку-квакушку"
# пропускаем вывод команды commit

$ echo "Зайчик-побегайчик" >> teremok.txt
$ git add teremok.txt
$ git commit -m "Поселить зайчика-побегайчика"

$ echo "Лисичка-сестричка" >> teremok.txt
$ git add teremok.txt
$ git commit -m "Поселить лисичку-сестричку"

$ echo "Волчок -- серый бочок" >> teremok.txt
$ git add teremok.txt
$ git commit -m "Поселить волчка -- серого бочка"

# Пришла очередь медведя косолапого.
# Как известно, конструкция теремка не была рассчитана на массу медведя
# и теремок развалился.
# Обратите внимание на одинарный символ >
$ echo "Теремок развален" > teremok.txt
$ git add teremok.txt
$ git commit -m "Попытаться поселить медведя косолапого" 
```
Если сейчас выполнить команду git log --oneline, получится примерно следующее.
```bash
$ git log --oneline
48fe3dc (HEAD -> master) Попытаться поселить медведя косолапого
318ebdb Поселить волчка -- серого бочка
470c115 Поселить лисичку-сестричку
e4ede9c Поселить зайчика-побегайчика
31cf9b3 Поселить лягушку-квакушку
d7d797a Поселить мышку-норушку
1c29af6 Исходное состояние теремка 
```

### Сравниваем коммиты
Теперь, когда сказка рассказана и у вас есть история коммитов, попробуем сравнить состояния файла `teremok.txt` между коммитами.
Например, чтобы получить максимально сокращённую версию сказки, можно сравнить состояние файлов на момент первого коммита (у нас это `1c29af6`) и последнего (у нас `48fe3dc`). 
Передадим команде `git diff` хеши обоих коммитов. Состояние файлов на момент первого переданного коммита будет сравниваться с состоянием файлов на момент второго.
Вместо `48fe3dc` можно было использовать `HEAD`: `git diff 1c29af6 HEAD`, потому что HEAD указывает на последний коммит.
Подселились: зайчик-побегайчик, лисичка-сестричка и волчок — серый бочок. Чёрные строки без знаков + или - — это «контекст», его `git diff` выводит только для того, чтобы стало понятно, что находится рядом с изменёнными (зелёными и красными) строками.
### Порядок аргументов `git diff`
По сути команда `git diff A B` выводит список инструкций: как превратить состояние `A` в состояние `B`. Если поменять `A` и B` местами (`git diff B A`), то и инструкции будут обратные: как превратить `B` в `A`. При этом все зелёные строки станут красными, и наоборот.
Попробуйте `git diff <конец сказки> <начало>`. Вместо `HEAD` (конец сказки) можно также передать хеш.

## Игнорирование файлов в Git
Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл `.gitignore` (от англ. ignore — «игнорировать») и записать в него названия игнорируемых файлов.
### Как заполнить `.gitignore`
С точки зрения Git `.gitignore` — это обычный текстовый файл. Его добавляют в корень репозитория и тоже коммитят.
В простейшем случае в `.gitignore` указывают все файлы, которые нужно игнорировать (по одному имени на строку). Но часто удобнее использовать шаблоны. Шаблон, или правило, — это способ указать сразу на несколько файлов с однотипными названиями.
💡 Правила из `.gitignore` применяются только к новым (`untracked`) файлам. Если файл уже попал в `staging area` или в коммит, то правила на него не распространяются.

### Комментарий
Если строка начинается с `#`, то это комментарий, и `.gitignore` не будет его учитывать.
```bash
# вот так можно писать комментарии;
# они ничего не значат для .gitignore,
# но они могут быть полезны, чтобы понять, зачем было добавлено то или иное правило 
```
### Просто название файла
Допустим, нужно, чтобы Git игнорировал все файлы `.DS_Store`. Для этого достаточно добавить в `.gitignore` строку с названием файла.
```bash
# для macOS
# macOS иногда создаёт скрытый файл .DS_Store для хранения настроек папки
.DS_Store 
```
В таком случае Git будет игнорировать файлы с именем `.DS_Store`, причём не только в корне репозитория, но и во всех вложенных папках.

### Звёздочка (`*`)
Символ звёздочки (`*`) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в `.gitignore`, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.
```bash
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg

# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp 
```
Теперь Git будет игнорировать все файлы, которые заканчиваются на `.jpeg` — пригодится тем, кто не любит картинки. А также все временные файлы `tmp` (от англ. temporary — «временный») в подпапках папки `docs`. Например, Git проигнорирует файл `docs/current/tmp`.  
Если задать правило, которое состоит только из звёздочки, Git будет игнорировать все файлы. Это происходит потому, что под звёздочку подходит любое имя файла.
```bash
# странное, но возможное правило
# "игнорировать все файлы"
* 
```

### Вопросительный знак (`?`)
Вопросительный знак `?` соответствует одному любому символу.
```bash
file?.txt 
```
Если сохранить такую запись в `.gitignore`, то будут проигнорированы, например, файлы `fileA.txt` и `file1.txt`. А вот файл `file12.txt` не будет проигнорирован, потому что в его названии два символа после `file`, а не один.

### Квадратные скобки (`[…]`)
Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках.
```bash
# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt 
```
В скобках можно либо перечислить символы (`[abc]`), либо задать диапазон (`[a-z]`).

### Слеш (`/`)
Косая черта, или слеш (`/`), указывает на каталоги. Если шаблон в `.gitignore` начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.
```bash
# игнорировать todo.txt в корне репозитория
/todo.txt

# для сравнения: spam.txt будет игнорироваться во всех папках
spam.txt 
```
Теперь файл `todo.txt` в корневом каталоге будет проигнорирован. При этом, например, файл `subdir/todo.txt` по-прежнему отслеживается.
Если шаблон заканчивается слешем, то правило применится только к папке.
```bash
# игнорировать папку build
build/ 
```
Обратите внимание: если `build` — это папка, то она будет проигнорирована. Если `build` — обычный файл, то он не подпадёт под правило и не будет игнорироваться.

### Парные звёздочки (`**`)
Функция парных звёздочек (`**`) похожа на функцию одинарной (`*`). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной.
```bash
# игнорировать файлы "docs/current/tmp", "docs/old/tmp",
# а также "docs/old/saved/a/b/c/d/tmp"
# и даже "docs/tmp", потому что ноль вложенных папок тоже подходит
docs/**/tmp

# игнорировать только "docs/current/tmp" и "docs/old/tmp"
# файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило
docs/*/tmp 
```
💡 Для двойной звёздочки верно то же самое, что и для одной: если задать правило `**`, то будут проигнорированы все файлы.

### Восклицательный знак (`!`)
Любое правило в файле `.gitignore` можно инвертировать с помощью восклицательного знака (`!`).
```bash
# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg 
```
Теперь файл `doge.jpeg` будет отслеживаться, хотя остальные `jpeg-файлы` будут проигнорированы. Такие правила удобны для добавления исключений из других правил `.gitignore`.

### Пример файла `.gitignore`
Содержание `.gitignore` может быть таким.
```bash
# игнорировать все файлы в каталоге build
build/

# игнорировать все .log файлы
*.log

# не игнорировать *.log файлы в examples
# потому что это пример для документации
!examples/**/*.log
```
 
### `.gitignore` и `git status`
Игнорируемые файлы не отображаются в выводе команды `git status`, иначе они бы засоряли вывод.
Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа `--ignored`: `git status --ignored`. В таком случае в выводе `git status` появится раздел `Ignored files`.