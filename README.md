# Шпаргалка по Git
## Навигация
* `pwd` (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;
* `ls` (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;
* `ls -a` — покажи также скрытые файлы и папки, названия которых начинаются с символа .;
* `cd first-project` (от англ. change directory, «сменить директорию») — перейди в папку first-project;
* `cd first-project/html` — перейди в папку html, которая находится в папке first-project;
* `cd ..` — перейди на уровень выше, в родительскую папку;
* `cd ~` — перейди в домашнюю директорию (/Users/Username);
* `cd /` — перейди в корневую директорию.
## Работа с файлами и папками
### Создание
* `touch index.html` (англ. touch, «коснуться») — создай файл index.html в текущей папке;
* `touch index.html style.css script.js` — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;
* `mkdir second-project` (от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке.
### Копирование и перемещение
* `cp file.txt ~/my-dir` (от англ. copy, «копировать») — скопируй файл в другое место;
* `mv file.txt ~/my-dir` (от англ. move, «переместить») — перемести файл или папку в другое место.
### Чтение
* `cat file.txt` (от англ. concatenate and print, «объединить и распечатать») — распечатай содержимое текстового файла file.txt.
### Удаление
* `rm about.html` (от англ. remove, «удалить») — удали файл about.html;
* `rmdir images` (от англ. remove directory, «удалить директорию») — удали папку images;
* `rm -r` second-project (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит.
### Полезные возможности
* Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (`&&`).
* У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
* Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.
Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

## Шпаркалка Markdown
[Шпаргалка Markdown](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)  
[еще](https://www.markdownguide.org/cheat-sheet/)  
[и еще](https://doka.guide/tools/markdown/)
### mermaid schemes
[mermaid schemes](https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/)

## Инициализируем репозиторий
### Сделать папку репозиторием — `git init`
Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием (от англ. repository — «хранилище»). Для этого следует переместиться в неё и ввести команду `git init` (от англ. initialize — «инициализировать»).  
Например, создайте папку first-project и сделайте её Git-репозиторием: перейдите в неё с помощью команды cd и выполните `git init`.  
```bash
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий
```
Вы можете создать папку в любом месте на компьютере. Но в этом случае не забывайте менять в наших примерах путь `~/dev/first-project` на тот, который ведёт к вашей папке. Помните, что не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.
В некоторых случаях при инициализации репозитория Git может показать объёмное сообщение, которое начинается со слов `Using 'master' as the name…`. Не пугайтесь: это не ошибка.
Также `git init` выведет сообщение вида `Initialized empty Git repository in <*ваша папка с проектом*>/.git/` (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»). В подпапке `.git` Git будет хранить всю служебную информацию.

### «Разгитить» папку, если что-то пошло не так, — rm -rf .git
Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку `.git`.
```bash
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git 
```
Разберём подробнее, что такое `-rf`:
ключ `-r` (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
ключ `-f` (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».
Будьте осторожны: в подпапке `.git` хранится история изменений. Если удалить `.git`, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.
### Проверить состояние репозитория — git status
После инициализации репозитория `first-project` запустите команду `git status` (от англ. status — «статус», «состояние») — она показывает текущее состояние репозитория.
Команда `git status` выведет:
- название текущей ветки: `On branch master` или `On branch main`;
- сообщение о том, что в репозитории ещё нет коммитов: `No commits yet`;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — `nothing to commit (create/copy files and use "git add" to track)`.

### Подготовить файлы к сохранению — `git add`
Создайте файлы `todo.txt` и `readme.txt` в папке `first-project` и запустите `git status`, чтобы посмотреть, что изменилось.
```bash
$ touch todo.txt
$ touch readme.txt
# создали файлы todo.txt и readme.txt

$ git status # проверили статус
```
Git сообщит, что в папке `first-project` есть `untracked files` (от англ. track — «следить», untracked — «неотслеженный», «неотслеживаемый») — ещё не отслеживаемые файлы `readme.txt` и `todo.txt`.

Состояние `untracked` значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.
Сейчас в `first-project` два файла. Мы хотим отслеживать состояние обоих, поэтому можем использовать команду `git add --all` (от англ. add — «добавить» + от англ. all — «всё»). Ключ, или флаг, `--all` позволяет подготовить к сохранению все файлы в репозитории.
```bash
$ git add --all # подготовили к сохранению все файлы в репозитории
$ git status # проверили статус 
```
Добавлять файлы можно и по одному, без ключа `--all`.
```bash
$ git add todo.txt
$ git add readme.txt
$ git status
```
Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.).
```bash
$ git add . # добавить всю текущую папку
$ git status
```
Получилось! Файлы, которые отмечены зелёным, теперь отслеживаются и готовы к сохранению. Но сохранения пока не произошло, потому что команда git add только запоминает текущее содержимое (контент) файла.
Если сейчас отредактировать любой из «зелёных» файлов в папке `first-project`, он перейдёт в состояние `modified` (англ. «изменённый») и будет и в «зелёном», и в «красном» списках.
Чтобы запомнить новое состояние файла, нужно снова ввести команду `git add` и передать в качестве параметра имя изменённого файла или ключ `--all`.
```bash
$ git add todo.txt
# или
$ git add --all 
```
Теперь файл `todo.txt` снова готов к сохранению! Будет сохранена последняя добавленная версия.
### Выполнить коммит — `git commit`
Сделать коммит можно командой `git commit` c ключом `-m` (от англ. message — «сообщение»), который присваивает коммиту сообщение.
Обычно в таком сообщении поясняется, в чём именно состояли изменения. Это как заметки на полях: благодаря им проще читать и понимать текст. Сообщение коммита выполняет те же функции — улучшает понимание и упрощает навигацию. Оно пишется после ключа `-m` в кавычках.
Например, перейдите в папку `first-project` и выполните коммит со следующим комментарием.
```bash
$ git commit -m ‘Мой первый коммит!’
```
После нажатия `Enter` текущая версия файлов будет сохранена в репозитории с сообщением Мой первый коммит!. Коммит (по названию команды `git commit`) — это по сути список файлов с их контентом.


Команда `git commit` выведет информацию о коммите.
1. `[master (root-commit) baa3b6e]` значит:
	* коммит был в ветке `master`;
	* `root-commit` — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
	* `baa3b6e` — сокращённый идентификатор коммита (подробнее об этом мы ещё расскажем).
2. 2 files changed, 1 insertion(+) значит:
	* изменились два файла (readme.txt и todo.txt);
	* одна строка была добавлена.  


Строки вида `create mode 100644 readme.txt` — это более подробная информация о новых (добавленных в Git) файлах.  `create` (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово `delete` (англ. «удалить»).
`mode 100644` сообщает, что это обычный файл. Также возможны варианты `100755` для исполняемых файлов (например, что-нибудь.exe) и `120000` для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.
💡 Обратите внимание: после того как вы сделали первый коммит, команда `git status` перестала выводить сообщение `No commits yet` (англ. «ещё нет коммитов»).
### Просмотреть историю коммитов — `git log`
Чтобы увидеть все коммиты, введите команду `git log` (от англ. log — «журнал [записей]»).
Обратите внимание, что по умолчанию `git log` выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

### Удаление Git Remote
Чтобы удалить пульт, перейдите в каталог, в котором хранится ваш репозиторий, и используйте команду `git remote rm` (или `git remote remove ...` ), за которой следует имя удаленного:
```bash
git remote rm <remote-name>
```
Например, чтобы удалить удаленное именованное `testing`, введите:
```bash
git remote rm testing
```
`git remote rm` удаляет все ссылки на удаленный репозиторий. Он не удаляет репозиторий с удаленного сервера.

Чтобы убедиться, что пульт был успешно удален, используйте команду `git remote -v` для списка удаленных подключений:
```bash
git remote -v
```
Результат будет выглядеть примерно так:
```bash
origin	https://github.com/user/repo_name.git (fetch)
origin	https://github.com/user/repo_name.git (push)
```
Команда `git remote rm` удаляет записи об удаленном репозитории из файла `.git/config`.
------------------

## SSH kyes
### Генерируем SSH-ключ
Обычно SSH-ключи находятся в директории `.ssh/`. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды.

```bash
$ ls -la .ssh/ # вывели список созданных ключей 
```

1. Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду.  
```bash
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.  
Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519.   
Ничего страшного: используйте другой алгоритм.  
```bash$ 
ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
``` 
После ввода отобразится такое сообщение.    
```bash
> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи
```
2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.
3. Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter для подтверждения.  
```bash
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again]
```
4. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду.
```bash
ls -a ~/.ssh
```
На экране должны появиться два файла — один с расширением `.pub`, другой — без. Файл в `.pub` — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому! 

После выполнения команды `ssh-keygen` из предыдущего урока в директории `~/.ssh` будет создано два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали):
`id_ed25519/id_rsa` — приватный ключ (файл без `.pub` в конце). Ни в коем случае не копируйте его и не делитесь им.
`id_ed25519.pub/id_rsa.pub` — публичный ключ (на это указывает расширение `.pub`).
1. Скопируйте содержимое файла с публичным ключом в буфер обмена.
```bash
# Windows
# скопировать содержимое ключа в буфер обмена:
$ clip < ~/.ssh/id_rsa.pub
# для ed25519:
$ clip < ~/.ssh/id_ed25519.pub
```
Если `clip` не сработает, выведите содержимое файла с помощью `cat ~/.ssh/id_rsa.pub` или `cat ~/.ssh/id_ed25519.pub` и скопируйте вывод в буфер обмена из консоли.
2. Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта. <br>
В меню слева нажмите на пункт SSH and GPG keys. <br>
В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»). <br>
В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»). <br>
В поле `Key type` (англ. «тип ключа») должно быть `Authentication Key` (англ. «ключ аутентификации»). <br> 
В поле Key скопируйте ваш ключ из буфера обмена. <br>
Нажмите на кнопку `Add SSH key` (англ. «добавить SSH-ключ»). <br>
Проверьте правильность ключа с помощью следующей команды.
```bash
$ ssh -T git@github.com 
```
```bash
Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
```
Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub по этой [ссылке](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.

## Привязать удалённый репозиторий к локальному — `git remote add`
Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно. Откройте консоль, перейдите в каталог локального репозитория и введите команду `git remote add` (от англ. remote — «удалённый» и add — «добавить»).
```bash
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
```
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово `origin`. А URL вы скопировали со страницы удалённого репозитория.  
**remark:**  
*В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания `Ctrl+V. На Windows (в Git Bash) и Linux для этого используется сочетание `Ctrl+Shift+V`. Также можно нажать правую кнопку мыши и выбрать пункт Paste (англ. «вставить») в выпадающем меню.*


`origin` (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.  
Убедиться, что репозитории связаны, — `git remote -v`.  
Отлично: вы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.
```bash
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```
В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
Флаг `-v` — короткая форма флага `--verbose` (англ. «подробный»). Он позволяет показать больше информации в выводе.
## Синхронизируем локальный и удалённый репозитории
Самая первая ветка в репозитории появляется автоматически и называется `main` (англ. «основная») или `master`. Её имя нужно указывать при отправке коммитов на удалённый репозиторий или при получении их из него.

### Отправить изменения на удалённый репозиторий — `git push`
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью `git add`, закоммитили их с комментарием командой `git commit -m`. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда `git push` (от англ. push — «толкать»).
В первый раз эту команду нужно вызвать с флагом `-u` и параметрами `origin` (имя удалённого репозитория) и `main` или `master` (название текущей ветки). Флаг `-u` свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.
```bash
$ git push -u origin master # Если команда приведёт к ошибке, попробуйте 
                          # заменить master на main.
```
При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.
Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.

## Хеш — идентификатор коммита
### Что такое хеш. Хеширование коммитов
`Хеширование` (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их `«отпечаток»` (англ. fingerprint).
Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или **родительский** (англ. parent), коммит.
Git хеширует (преобразует) информацию о коммите с помощью алгоритма **SHA-1** (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный **хеш** — результат хеширования.
Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 
0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:
* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).
Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 на этом [сайте](https://emn178.github.io/online-tools/sha1.html) — попробуйте ввести в поле **input** (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле **output** (англ. «вывод»).
### Хеш — основной идентификатор коммита
Git хранит таблицу соответствий `хеш → информация о коммите`. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.
При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке `.git` в репозитории проекта.

## ЛОГ

После вызова `git log` появляется список коммитов.
Вот так выглядит описание самого первого коммита в репозитории Git
```bash
commit e83c5163316f89bfbde7d9ab23ca2e25604af290 # хэш коммита
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 7 15:13:13 2005 -0700

    Initial revision of "git", the information manager from hell 
```
### Получить сокращённый лог — `git log --oneline`
Получить сокращённый лог можно с помощью команды `git log` с флагом `--oneline` (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда `git log --oneline` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.
**remark**
Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу `Q` (от англ. Quit — «выйти») в английской раскладке клавиатуры.

### HEAD — всему голова
При вызове команды `git log` вы также могли заметить надпись `(HEAD -> master)` после хеша одного из коммитов.
#### Файл HEAD
Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git. Он указывает на коммит, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейдите в папку `.git` командой `cd`. Посмотрите содержимое файла `HEAD` командой `cat`.
```bash
$ pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка 
```
Внутри `HEAD` — ссылка на служебный файл: `refs/heads/master` (или refs/heads/main` в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
```bash
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты 
```
Когда вы делаете коммит, Git обновляет `refs/heads/master` — записывает в него хеш последнего коммита. Получается, что `HEAD` тоже обновляется, так как ссылается на `refs/heads/master`.
При работе с Git указатель `HEAD` используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово `HEAD` — Git поймёт, что вы имели в виду последний коммит.

## Статусы файлов в Git
До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог `git add`, а можно было просто сделать коммит (svn commit). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.
Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. Хотя сначала это может показаться сложным, со временем вы оцените удобство более явного подхода.

### Статусы `untracked/tracked`, `staged и `modified`
* `untracked` (англ. «неотслеживаемый»)
	Мы говорили, что новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
* `staged` (англ. «подготовленный»)
	После выполнения команды `git add` файл попадает в `staging area` (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.

Если сравнивать коммит с фотографией, то можно сказать, что команда `git add` добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а `git commit` делает снимок всей сцены целиком.   
**Staging area, index и cache**
Staging area также называют **index** (англ. «каталог») или **cache** (англ. «кеш»), а состояние файла `staged` иногда называют indexed` или `cached`.
Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow.
* tracked (англ. «отслеживаемый»)
	Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit`, а также файлы, которые были добавлены в staging area` командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
* modified (англ. «изменённый»)
	Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.  
Для файлов в состояниях `staged` и `modified обычно не указывают, что они также `tracked, потому что это состояние подразумевается.
#### Про `staged` и `modified`
Команда `git add` добавляет в `staging area` только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените `file.txt`, то новое содержимое файла не будет находиться в `staging`.
Git сообщит об этом с помощью статуса modified`: файл изменён относительно той версии, которая уже в `staging`. Чтобы добавить в `staging` последнюю версию, нужно выполнить `git add file.txt` ещё раз.

### Типичный жизненный цикл файла в Git
1. Файл только что создали. Git про него ещё ничего не знает. Состояние: `untracked`.
2. Файл добавили в `staging area` с помощью `git add`. Состояние: `staged` (+ `tracked`).
	* Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`).
		Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий.
	* Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).
3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.
4. Изменили файл. Состояние: `modified` (+ `tracked`).
5. Снова добавили в staging area с помощью `git add`. Состояния: `staged` (+ `tracked`).
6. Сделали коммит. Состояния: `tracked`.
7. Повторили пункты 4−7 много-много раз.

### SCHEME

```mermaid
  flowchart TD;
      iframe->>dotcom: git add
      untracked-->staged;
      iframe->>dotcom: git commit
      staged-->tracked;
      iframe->>dotcom: file's changies
      tracked-->modified;
      iframe->>dotcom: git add
      modified-->staged;
      iframe->>dotcom: file's changies
      staged-->modified;
```

## git status
Большинство файлов в типичном проекте будут находиться в состоянии `tracked` (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды `git status` — иначе она бы каждый раз выводила список вообще всех файлов проекта.
В итоге `git status` показывает только следующие состояния файлов:
* `staged` (`Changes to be committed в выводе git status`);
* `modified` (`Changes not staged for commit`);
* `untracked` (`Untracked files`).


